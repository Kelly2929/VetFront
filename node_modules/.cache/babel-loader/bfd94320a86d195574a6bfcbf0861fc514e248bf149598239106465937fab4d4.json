{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\Moshe\\\\Downloads\\\\VetChat (1)\\\\VetChat\\\\frontend\\\\src\\\\context\\\\VideoChatContext.js\",\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\nimport { createContext, useState, useRef, useEffect, useContext } from \"react\";\nimport { io } from \"socket.io-client\";\nimport Peer from \"simple-peer\";\nimport { useAuth } from \"./AuthContext\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst SocketContext = /*#__PURE__*/createContext();\nexport function useVideoChatContext() {\n  _s();\n  return useContext(SocketContext);\n}\n_s(useVideoChatContext, \"gDsCjeeItUuvgOWf1v4qoK9RF6k=\");\nconst socket = io(\"http://localhost:8080\");\nconst VideoChatProvider = ({\n  children\n}) => {\n  _s2();\n  const {\n    currentUser,\n    currentUserToken\n  } = useAuth();\n  const [callAccepted, setCallAccepted] = useState(false);\n  const [callEnded, setCallEnded] = useState(false);\n  const [isReceivingCall, setIsReceivingCall] = useState(false);\n  const [callerData, setCallerData] = useState(); //will hold the customer mongoId\n  const [callerSignal, setCallerSignal] = useState();\n  const [stream, setStream] = useState({});\n  const [name, setName] = useState(\"\");\n  const [call, setCall] = useState({});\n  const [me, setMe] = useState(\"\");\n  const myVideo = useRef();\n  const userVideo = useRef();\n  const connectionRef = useRef();\n  console.log(\"connectionRef\", connectionRef);\n  useEffect(() => {\n    navigator.mediaDevices.getUserMedia({\n      video: true,\n      audio: true\n    }).then(stream => {\n      setStream(stream);\n      if (myVideo.current) {\n        myVideo.current.srcObject = stream;\n      }\n    }).catch(e => {\n      console.error(\"Failed to get local stream: \", e.message);\n    });\n    if (currentUser && currentUser.isVet) {\n      socket.emit(\"registerVet\", {\n        token: currentUserToken\n      });\n      // socket.on(\"confirmReg\", (d) => {\n      //   console.log(d);\n      // });\n      socket.on(\"callFromClient\", data => {\n        console.log(\"callFromClient\", data);\n        setIsReceivingCall(true);\n        setCallerData(data); //callerData type {signalData,fromSocketId,mongoDbId}\n        setCallerSignal(data.signalData);\n        //here should add the socket id of the user that we got the call from\n      });\n    }\n  }, []);\n\n  //Will be used by the Vet\n  const answerCall = () => {\n    setCallAccepted(true);\n    try {\n      console.log(\"stream before new peer for vet\", stream);\n      const peer = new Peer({\n        initiator: false,\n        trickle: false,\n        stream\n      });\n      peer.on(\"signal\", data => {\n        socket.emit(\"answerCall\", {\n          signal: data,\n          to: callerData.fromSocketId\n        });\n      });\n      peer.on(\"stream\", currentStream => {\n        if (currentStream == null) {\n          leaveCall();\n        } else {\n          userVideo.current.srcObject = currentStream;\n        }\n      });\n      peer.on(\"error\", err => {\n        console.error(\"Peer connection error:\", err);\n        leaveCall(); // Ensure cleanup on error\n      });\n      peer.signal(callerSignal);\n      connectionRef.current = peer;\n    } catch (e) {\n      console.log(e);\n    }\n  };\n\n  //Will be used by the User\n  const callVet = id => {\n    try {\n      const peer = new Peer({\n        initiator: true,\n        trickle: false,\n        stream\n      });\n      peer.on(\"signal\", data => {\n        console.log(\"signall!!!1\");\n        socket.emit(\"callVet\", {\n          signalData: data,\n          // from: me, i dont think i need it i can just like do socket.id\n          name: currentUser.name,\n          mongoDbId: currentUser.id //later will send the token for actual confirmation\n        });\n      });\n      peer.on(\"stream\", currentStream => {\n        userVideo.current.srcObject = currentStream;\n      });\n      peer.on(\"error\", err => {\n        console.error(\"Peer connection error:\", err);\n        leaveCall(); // Ensure cleanup on error\n      });\n      socket.on(\"callAccepted\", signal => {\n        setCallAccepted(true);\n        peer.signal(signal);\n      });\n      connectionRef.current = peer;\n    } catch (e) {}\n  };\n\n  //Will be used by both the User and the Vet\n  const leaveCall = () => {\n    setCallEnded(true);\n    // connectionRef.current.destroy();\n    window.location.reload();\n  };\n  return /*#__PURE__*/_jsxDEV(SocketContext.Provider, {\n    value: {\n      call,\n      callAccepted,\n      myVideo,\n      userVideo,\n      stream,\n      name,\n      setName,\n      callEnded,\n      me,\n      callVet,\n      leaveCall,\n      answerCall,\n      isReceivingCall,\n      callerData\n    },\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 128,\n    columnNumber: 5\n  }, this);\n};\n_s2(VideoChatProvider, \"vUhqICxau9BPQQng4hj6i0vxgrA=\", false, function () {\n  return [useAuth];\n});\n_c = VideoChatProvider;\nexport { VideoChatProvider, SocketContext };\nvar _c;\n$RefreshReg$(_c, \"VideoChatProvider\");","map":{"version":3,"names":["createContext","useState","useRef","useEffect","useContext","io","Peer","useAuth","jsxDEV","_jsxDEV","SocketContext","useVideoChatContext","_s","socket","VideoChatProvider","children","_s2","currentUser","currentUserToken","callAccepted","setCallAccepted","callEnded","setCallEnded","isReceivingCall","setIsReceivingCall","callerData","setCallerData","callerSignal","setCallerSignal","stream","setStream","name","setName","call","setCall","me","setMe","myVideo","userVideo","connectionRef","console","log","navigator","mediaDevices","getUserMedia","video","audio","then","current","srcObject","catch","e","error","message","isVet","emit","token","on","data","signalData","answerCall","peer","initiator","trickle","signal","to","fromSocketId","currentStream","leaveCall","err","callVet","id","mongoDbId","window","location","reload","Provider","value","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["C:/Users/Moshe/Downloads/VetChat (1)/VetChat/frontend/src/context/VideoChatContext.js"],"sourcesContent":["import { createContext, useState, useRef, useEffect, useContext } from \"react\";\r\nimport { io } from \"socket.io-client\";\r\nimport Peer from \"simple-peer\";\r\nimport { useAuth } from \"./AuthContext\";\r\n\r\nconst SocketContext = createContext();\r\n\r\nexport function useVideoChatContext() {\r\n  return useContext(SocketContext);\r\n}\r\n\r\nconst socket = io(\"http://localhost:8080\");\r\nconst VideoChatProvider = ({ children }) => {\r\n  const { currentUser, currentUserToken } = useAuth();\r\n\r\n  const [callAccepted, setCallAccepted] = useState(false);\r\n  const [callEnded, setCallEnded] = useState(false);\r\n\r\n  const [isReceivingCall, setIsReceivingCall] = useState(false);\r\n\r\n  const [callerData, setCallerData] = useState(); //will hold the customer mongoId\r\n  const [callerSignal, setCallerSignal] = useState();\r\n\r\n  const [stream, setStream] = useState({});\r\n  const [name, setName] = useState(\"\");\r\n  const [call, setCall] = useState({});\r\n  const [me, setMe] = useState(\"\");\r\n\r\n  const myVideo = useRef();\r\n  const userVideo = useRef();\r\n\r\n  const connectionRef = useRef();\r\n  console.log(\"connectionRef\",connectionRef)\r\n  useEffect(() => {\r\n    navigator.mediaDevices\r\n      .getUserMedia({ video: true, audio: true })\r\n      .then((stream) => {\r\n        setStream(stream);\r\n        if (myVideo.current) {\r\n          myVideo.current.srcObject = stream;\r\n        }\r\n      })\r\n      .catch((e) => {\r\n        console.error(\"Failed to get local stream: \", e.message);\r\n      });\r\n\r\n    if (currentUser && currentUser.isVet) {\r\n      socket.emit(\"registerVet\", { token: currentUserToken });\r\n      // socket.on(\"confirmReg\", (d) => {\r\n      //   console.log(d);\r\n      // });\r\n      socket.on(\"callFromClient\", (data) => {\r\n        console.log(\"callFromClient\", data);\r\n        setIsReceivingCall(true);\r\n        setCallerData(data); //callerData type {signalData,fromSocketId,mongoDbId}\r\n        setCallerSignal(data.signalData);\r\n        //here should add the socket id of the user that we got the call from\r\n      });\r\n    }\r\n  }, []);\r\n\r\n  //Will be used by the Vet\r\n  const answerCall = () => {\r\n    setCallAccepted(true);\r\n    try {\r\n      console.log(\"stream before new peer for vet\", stream);\r\n      const peer = new Peer({ initiator: false, trickle: false, stream });\r\n      peer.on(\"signal\", (data) => {\r\n        socket.emit(\"answerCall\", {\r\n          signal: data,\r\n          to: callerData.fromSocketId,\r\n        });\r\n      });\r\n      peer.on(\"stream\", (currentStream) => {\r\n        if (currentStream == null) {\r\n          leaveCall();\r\n        } else {\r\n          userVideo.current.srcObject = currentStream;\r\n        }\r\n      });\r\n      peer.on(\"error\", (err) => {\r\n        console.error(\"Peer connection error:\", err);\r\n        leaveCall(); // Ensure cleanup on error\r\n      });\r\n      peer.signal(callerSignal);\r\n      connectionRef.current = peer;\r\n    } catch (e) {\r\n      console.log(e);\r\n    }\r\n  };\r\n\r\n  //Will be used by the User\r\n  const callVet = (id) => {\r\n    try {\r\n      const peer = new Peer({ initiator: true, trickle: false, stream });\r\n      peer.on(\"signal\", (data) => {\r\n        console.log(\"signall!!!1\")\r\n        socket.emit(\"callVet\", {\r\n          signalData: data,\r\n          // from: me, i dont think i need it i can just like do socket.id\r\n          name: currentUser.name,\r\n          mongoDbId: currentUser.id, //later will send the token for actual confirmation\r\n        });\r\n      });\r\n      peer.on(\"stream\", (currentStream) => {\r\n        userVideo.current.srcObject = currentStream;\r\n      });\r\n      peer.on(\"error\", (err) => {\r\n        console.error(\"Peer connection error:\", err);\r\n        leaveCall(); // Ensure cleanup on error\r\n      });\r\n      socket.on(\"callAccepted\", (signal) => {\r\n        setCallAccepted(true);\r\n        peer.signal(signal);\r\n      });\r\n      connectionRef.current = peer;\r\n    } catch (e) {}\r\n  };\r\n\r\n  //Will be used by both the User and the Vet\r\n  const leaveCall = () => {\r\n    setCallEnded(true);\r\n    // connectionRef.current.destroy();\r\n    window.location.reload();\r\n  };\r\n\r\n  return (\r\n    <SocketContext.Provider\r\n      value={{\r\n        call,\r\n        callAccepted,\r\n        myVideo,\r\n        userVideo,\r\n        stream,\r\n        name,\r\n        setName,\r\n        callEnded,\r\n        me,\r\n        callVet,\r\n        leaveCall,\r\n        answerCall,\r\n        isReceivingCall,\r\n        callerData,\r\n      }}\r\n    >\r\n      {children}\r\n    </SocketContext.Provider>\r\n  );\r\n};\r\nexport { VideoChatProvider, SocketContext };\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}